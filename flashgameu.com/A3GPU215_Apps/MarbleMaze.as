package {	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.geom.*;	import flash.utils.getTimer;    import flash.sensors.Accelerometer;		public class MarbleMaze extends MovieClip {				// constants		static const speed:Number = .3;		static const marbleSize:Number = 20;		static const holeDist:Number = 5;		static const mapRect:Rectangle = new Rectangle(2,2,316,476);				// game objects		private var blocks:Array;				// accelerometer object		private var accelerometer:Object;        		// game variables		private var dx,dy:Number;		private var lastTime:int;				public function startMarbleMaze() {						// get blocks			findBlocks();						// set starting movement			dx = 0.0;			dy = 0.0;						// add listeners			this.addEventListener(Event.ENTER_FRAME,gameLoop);					// set up accelerometer or simulate with arrow keys			if (Accelerometer.isSupported) {				accelerometer = new Accelerometer();				accelerometer.addEventListener(AccelerometerEvent.UPDATE, accelerometerHandler);			} else {				stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownFunction);				stage.addEventListener(KeyboardEvent.KEY_UP, keyUpFunction);				stage.focus = stage;			}		}		// find all Block objects		public function findBlocks() {			blocks = new Array();			for(var i=0;i<gamesprite.numChildren;i++) {				var mc = gamesprite.getChildAt(i);				if (mc is Block) {					blocks.push(mc);				}			}		}				// set movement according to accelerometer		private function accelerometerHandler(e) {			dx = -e.accelerationX;			dy = e.accelerationY;		}				// simulate accelerometer with arrow keys		public function keyDownFunction(event:KeyboardEvent) {			if (event.keyCode == 37) {				dx = -.5;			} else if (event.keyCode == 39) {				dx = .5;			} else if (event.keyCode == 38) {				dy = -.5;			} else if (event.keyCode == 40) {				dy = .5;			}		}				public function keyUpFunction(event:KeyboardEvent) {			if (event.keyCode == 37) {				dx = 0;			} else if (event.keyCode == 39) {				dx = 0;			} else if (event.keyCode == 38) {				dy = 0;			} else if (event.keyCode == 40) {				dy = 0;			}		}		// main game code		public function gameLoop(event:Event) {					// calculate time passed			if (lastTime == 0) lastTime = getTimer();			var timeDiff:int = getTimer()-lastTime;			lastTime += timeDiff;						// move the marble			moveMarble(timeDiff);						// check to see if it is in the hole			if (Point.distance(new Point(gamesprite.marble.x,gamesprite.marble.y), new Point(gamesprite.hole.x, gamesprite.hole.y)) < holeDist) {				 endGame();			}		}				// move marble forward		public function moveMarble(timeDiff:Number) {			// calculate current marble area			var marbleRect = new Rectangle(gamesprite.marble.x-marbleSize/2, gamesprite.marble.y-marbleSize/2, marbleSize, marbleSize);						// calculate new marble area			var newMarbleRect = marbleRect.clone();			newMarbleRect.x += dx*speed*timeDiff;			newMarbleRect.y += dy*speed*timeDiff;						// calculate new location			var newX:Number = gamesprite.marble.x + dx*speed*timeDiff;			var newY:Number = gamesprite.marble.y + dy*speed*timeDiff;						// loop through blocks and check collisions			for(var i:int=0;i<blocks.length;i++) {								// get block rectangle, see if there is a collision				var blockRect:Rectangle = blocks[i].getRect(gamesprite);				if (blockRect.intersects(newMarbleRect)) {							// horizontal push-back					if (marbleRect.right <= blockRect.left) {						newX += blockRect.left - newMarbleRect.right;						dx = 0;					} else if (marbleRect.left >= blockRect.right) {						newX += blockRect.right - newMarbleRect.left;						dx = 0;					}										// vertical push-back					if (marbleRect.top >= blockRect.bottom) {						newY += blockRect.bottom - newMarbleRect.top;						dy = 0;					} else if (marbleRect.bottom <= blockRect.top) {						newY += blockRect.top - newMarbleRect.bottom;						dy = 0;					}				}							}					// check for collisions with sidees			if ((newMarbleRect.right > mapRect.right) && (marbleRect.right <= mapRect.right)) {				newX += mapRect.right - newMarbleRect.right;				dx = 0;			}			if ((newMarbleRect.left < mapRect.left) && (marbleRect.left >= mapRect.left)) {				newX += mapRect.left - newMarbleRect.left;				dx = 0;			}			if ((newMarbleRect.top < mapRect.top) && (marbleRect.top >= mapRect.top)) {				newY += mapRect.top-newMarbleRect.top;				dy = 0;			}			if ((newMarbleRect.bottom > mapRect.bottom) && (marbleRect.bottom <= mapRect.bottom)) {				newY += mapRect.bottom - newMarbleRect.bottom;				dy = 0;			}					// set new marble location			gamesprite.marble.x = newX;			gamesprite.marble.y = newY;		}				// game over, remove listeners		public function endGame() {			blocks = null;			this.removeEventListener(Event.ENTER_FRAME,gameLoop);			if (Accelerometer.isSupported) {				accelerometer.removeEventListener(AccelerometerEvent.UPDATE, accelerometerHandler);				accelerometer = null;			} else {				stage.removeEventListener(KeyboardEvent.KEY_DOWN,keyDownFunction);				stage.removeEventListener(KeyboardEvent.KEY_UP,keyUpFunction);			}			gotoAndStop("gameover");		}			}		}